<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>NINJA FROST monitor page</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- REMOVED meta refresh to avoid losing audio permission on reload -->
  <style>
    :root {
      --ok: #0ac70a;
      --warn: #d40000;
      --banner-ok-bg: #0b7a0b;
      --banner-warn-bg: #990000;
      --banner-fg: #ffffff;
    }
    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      color:#000; background:#fff; margin: 2rem 3rem;
    }
    h1 { font-size: 2.2rem; margin-bottom: 0.2rem; }
    h2 { font-size: 1.6rem; margin: 0.8rem 0 0.4rem; }
    hr { border:0; border-top:4px solid #000; margin:1rem 0; }
    table { border-collapse: collapse; font-size: 1rem; min-width: 420px; margin-bottom: 1rem; }
    caption { text-align:left; font-weight:700; font-size:1.1rem; margin: 0.5rem 0; }
    td, th { border: 2px solid #000; padding: 0.4rem 0.6rem; }
    th { background: #f0f0f0; text-align:left; }
    .note { font-size: 1rem; }
    .lamp {
      width: 26px; height: 26px; border-radius: 50%;
      display:inline-block; margin-left:10px; vertical-align:middle;
      box-shadow: 0 0 10px rgba(0,0,0,0.4);
      border: 2px solid #222;
    }
    .green { background-color: var(--ok); }
    .red { background-color: var(--warn); }

    /* Unified status banner */
    #status-banner {
      position: sticky; top: 0; z-index: 1000;
      display: block;
      color: var(--banner-fg);
      padding: 0.6rem 1rem; font-weight: 700; letter-spacing: 0.3px;
      border-radius: 8px; margin-bottom: 1rem; text-align: center;
      box-shadow: 0 6px 16px rgba(0,0,0,0.25);
    }
    #status-banner.ok { background: var(--banner-ok-bg); }
    #status-banner.warn { background: var(--banner-warn-bg); animation: blink 1.2s steps(2, start) infinite; }
    @keyframes blink { 50% { opacity: 0.2; } }

    /* Enable sound bar (shown until user clicks) */
    #enable-bar {
      position: sticky; top: 0; z-index: 1001;
      background: #f7f7f7; border: 1px solid #bbb; border-radius: 8px;
      padding: 8px 12px; margin-bottom: 10px; display: none;
      box-shadow: 0 6px 16px rgba(0,0,0,0.15);
    }
    #enable-sound {
      padding: 6px 12px; border: 1px solid #333; border-radius: 6px;
      background:#f5f5f5; cursor:pointer; font-weight:600; margin-left: 8px;
    }
    @keyframes pulse { 0%{transform:scale(1)} 50%{transform:scale(1.03)} 100%{transform:scale(1)} }
ã€€.img-left {
  display: block !important;
  margin-left: 0 !important;
  margin-right: auto !important;
ã€€}
  </style>
</head>
<body>
  <!-- Unified status banner (green/ok or red/warn in the same place) -->
  <div id="status-banner" class="ok" role="status" aria-live="polite">  
    âœ… All good: data updated within the last 30 minutes.
  </div>

  <!-- Sound enable prompt (shown until user enables) -->
  <div id="enable-bar">
    ðŸ”Š To allow alarms to play automatically, please click:
    <button id="enable-sound">Enable sound (click once)</button>
  </div>

  <hr>
  <h1><strong>NINJA FROST monitor page</strong></h1>
  <hr>

  <h2><strong>Status of DAQ for FROST in NINJA physics run c (E71c)</strong></h2>
  <p class="note">These results are updated automatically.</p>

  <table>
    <caption>Latest dat file</caption>
    <tr>
      <th scope="row">Current run</th>
      <td id="run-cell">Loading...</td>
    </tr>
    <tr>
      <th scope="row">Last modified time of the latest dat file (JST)</th>
      <td id="date-cell">Loading...</td>
    </tr>
  </table>

  <h3>Status Lamp:
    <span id="lamp" class="lamp green" aria-label="status lamp"></span>
  </h3>

 <!-- ===================== (1) Data set table ===================== -->
  <table>
    <caption>Data set for accumulated POT</caption>
    <tr>
      <th scope="row">Period</th>
      <td><script src="figs/dataquality_withBSD/pot_info/period.js"></script></td>
    </tr>
    <tr>
      <th scope="row">Delivered spills</th>
      <td><script src="figs/dataquality_withBSD/pot_info/delivered_spills.js"></script></td>
    </tr>
    <tr>
      <th scope="row">Recorded spills</th>
      <td><script src="figs/dataquality_withBSD/pot_info/recorded_spills.js"></script></td>
    </tr>
    <tr>
      <th scope="row">Delivered POT</th>
      <td><script src="figs/dataquality_withBSD/pot_info/delivered_pot.js"></script></td>
    </tr>
    <tr>
      <th scope="row">Recorded POT</th>
      <td><script src="figs/dataquality_withBSD/pot_info/recorded_pot.js"></script></td>
    </tr>
    <tr>
      <th scope="row">Data taking efficiency</th>
      <td><script src="figs/dataquality_withBSD/pot_info/efficiency.js"></script></td>
    </tr>
  </table>

  <!-- ===================== (2) Accumulated POT plotã€€===================== -->
  <h2>Accumulated POT</h2>
  <img
     src="figs/dataquality_withBSD/pot_plot/accumulated_pot_withBSD.png"
     alt="Accumulated POT"
     class="img-left"
     style="width:60%; max-width:100%;">

  <!-- ===================== (3) Event rate / sand muon rate stability ===================== -->
  <h2>Event rate (or sand muon rate) stability</h2>
  <img
    src="figs/dataquality_withBSD/eventrate_plot/eventrate_plot.png"
    alt="Event rate (or sand muon rate) stability"
    style="width:60%; max-width:100%; display:block; margin-left:0;">


  <!-- ===================== (4) Data quality check ===================== -->
  <h2>Data quality check</h2>

  <h3>1. Unixtime</h3>
  <img
    id="plot-unixtime"
    src=""
    alt="Unixtime plot"
    style="width:60%; max-width:100%; display:block; margin-left:0;">

  <h3>2. Spill Number</h3>
  <img
    id="plot-spillnum"
    src=""
    alt="Spill number plot"
    style="width:60%; max-width:100%; display:block; margin-left:0;">


  <h3>3. TDC</h3>
  <p class="note">The following four plots are shown for the latest run: leading, trailing, leading_fromadc, trailing_fromadc.</p>
  <img
    id="plot-tdc-leading"
    src=""
    alt="TDC leading"
    style="width:60%; max-width:100%; display:block; margin-left:0;">
  <img
    id="plot-tdc-trailing"
    src=""
    alt="TDC trailing"
    style="width:60%; max-width:100%; display:block; margin-left:0;">
  <img
    id="plot-tdc-leading-fromadc"
    src=""
    alt="TDC leading_fromadc"
    style="width:60%; max-width:100%; display:block; margin-left:0;">
  <img
    id="plot-tdc-trailing-fromadc"
    src=""
    alt="TDC trailing_fromadc"
    style="width:60%; max-width:100%; display:block; margin-left:0;">

  <h3>4. Average light yield per channel</h3>
  <img
    id="plot-lightyield-chavg"
    src=""
    alt="Average light yield per channel"
    style="width:60%; max-width:100%; display:block; margin-left:0;">

  <h3>5. Average light yield history</h3>
  <img
    src="figs/dataquality/lightyield/ALL_chavg_lightyield_history_2D_6h.png"
    alt="Average light yield history"
    style="width:80%; max-width:100%; display:block; margin-left:0;">

  <h3>6. xg vs yg</h3>
  <img
    id="plot-xgyg"
    src=""
    alt="xg vs yg"
    style="width:60%; max-width:100%; display:block; margin-left:0;">

  <!-- Local buzzer sound -->
  <audio id="beep-sound" preload="auto">
    <source src="se_amb01.wav" type="audio/wav">
  </audio>

  <!-- ===== Previous run reference plots (hidden if nothing found) ===== -->
  <hr>
  <div id="prev-section" style="display:none; margin-top:2rem;">
    <h2>Previous data quality (reference)</h2>
    <p class="note">
      Previous run (reference):
      <span id="prev-run-label"></span>
    </p>

    <h3>1. Unixtime (previous run)</h3>
    <img
      id="prev-plot-unixtime"
      src=""
      alt="Unixtime plot (previous run)"
      style="width:60%; max-width:100%; display:block; margin-left:0;">

    <h3>2. Spill Number (previous run)</h3>
    <img
      id="prev-plot-spillnum"
      src=""
      alt="Spill number plot (previous run)"
      style="width:60%; max-width:100%; display:block; margin-left:0;">

    <h3>3. TDC (previous run)</h3>
    <p class="note">The following four plots are shown for the previous run: leading, trailing, leading_fromadc, trailing_fromadc.</p>
    <img
      id="prev-plot-tdc-leading"
      src=""
      alt="TDC leading (previous run)"
      style="width:60%; max-width:100%; display:block; margin-left:0;">
    <img
      id="prev-plot-tdc-trailing"
      src=""
      alt="TDC trailing (previous run)"
      style="width:60%; max-width:100%; display:block; margin-left:0;">
    <img
      id="prev-plot-tdc-leading-fromadc"
      src=""
      alt="TDC leading_fromadc (previous run)"
      style="width:60%; max-width:100%; display:block; margin-left:0;">
    <img
      id="prev-plot-tdc-trailing-fromadc"
      src=""
      alt="TDC trailing_fromadc (previous run)"
      style="width:60%; max-width:100%; display:block; margin-left:0;">

    <h3>4. Average light yield per channel (previous run)</h3>
    <img
      id="prev-plot-lightyield-chavg"
      src=""
      alt="Average light yield per channel (previous run)"
      style="width:60%; max-width:100%; display:block; margin-left:0;">

    <h3>6. xg vs yg (previous run)</h3>
    <img
      id="prev-plot-xgyg"
      src=""
      alt="xg vs yg (previous run)"
      style="width:60%; max-width:100%; display:block; margin-left:0;">
  </div>

  <script>
    // ===== Settings =====
    const THRESHOLD_MINUTES = 30;
    const RUN_JS  = "figs/latestdat_info/latestdat_run.js";
    const DATE_JS = "figs/latestdat_info/latestdat_date.js";

    let soundEnabled = false;
    let lastIsOk = true; // track last state for watchdog
    let testAlarmPlaying = false; // for manual test play/stop
    let prevRunResolved = false;   // whether we've already searched for previous run
    let prevRunValue = null;       // cached previous run string (e.g. "run00003")

    function extractWriteValue(jsText) {
      const m = jsText.match(/document\.write\(\s*"([^"]*)"\s*\)\s*;?/);
      return m ? m[1] : null;
    }

    async function fetchValueFromJs(jsPath) {
      // Some servers return 403 for JS files when a query string is attached.
      // So we avoid adding "?cb=..." here and rely on cache: 'no-store'.
      const url = jsPath;
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error("Fetch failed: " + jsPath);
      const text = await res.text();
      return extractWriteValue(text);
    }

    function injectScriptAndCapture(jsPath) {
      return new Promise((resolve, reject) => {
        const originalWrite = document.write;
        let captured = "";
        document.write = (s) => { captured += String(s); };
        const cleanup = () => { document.write = originalWrite; };
        const done = () => { cleanup(); captured ? resolve(captured) : reject(new Error("No output captured: " + jsPath)); };
        const script = document.createElement("script");
        script.src = jsPath;
        script.onload = done;
        script.onerror = () => { cleanup(); reject(new Error("Script load error: " + jsPath)); };
        document.body.appendChild(script);
        setTimeout(done, 3000);
      });
    }

    function toDateJST(str) {
      const m = str && str.match(/^(\d{4})\/(\d{2})\/(\d{2})\s+(\d{2}):(\d{2})$/);
      if (!m) return null;
      const [_, y, mo, d, hh, mm] = m;
      return new Date(`${y}-${mo}-${d}T${hh}:${mm}:00+09:00`);
    }

    function setLamp(isOk) {
      const lamp = document.getElementById('lamp');
      lamp.classList.toggle('green', isOk);
      lamp.classList.toggle('red', !isOk);
    }

    function setStatusBanner(isOk) {
      const banner = document.getElementById('status-banner');
      if (!banner) return;
      banner.classList.toggle('ok', isOk);
      banner.classList.toggle('warn', !isOk);
      banner.textContent = isOk        
        ? "âœ… All good: data updated within the last 30 minutes."
        : "âš ï¸ Warning: data not updated for more than 30 minutes!";
      banner.setAttribute('role', isOk ? 'status' : 'alert');
      banner.setAttribute('aria-live', isOk ? 'polite' : 'assertive');
    }

    // Update PNG plots that depend on the current run number
    function updateRunDependentPlots(runVal) {
      if (!runVal) return;
      const run = runVal.trim(); // expected like "run00106"

      const unixtime = document.getElementById('plot-unixtime');
      if (unixtime) {
        unixtime.src = `figs/dataquality/unixtime/${run}_evnum_vs_unixtime.png`;
      }

      const spillnum = document.getElementById('plot-spillnum');
      if (spillnum) {
        spillnum.src = `figs/dataquality/spillnum/${run}_evnum_vs_spillnum.png`;
      }

      const tdcLeading = document.getElementById('plot-tdc-leading');
      if (tdcLeading) {
        tdcLeading.src = `figs/dataquality/tdc/${run}_leading_hist.png`;
      }

      const tdcTrailing = document.getElementById('plot-tdc-trailing');
      if (tdcTrailing) {
        tdcTrailing.src = `figs/dataquality/tdc/${run}_trailing_hist.png`;
      }

      const tdcLeadingFromAdc = document.getElementById('plot-tdc-leading-fromadc');
      if (tdcLeadingFromAdc) {
        tdcLeadingFromAdc.src = `figs/dataquality/tdc/${run}_leading_fromadc_hist.png`;
      }

      const tdcTrailingFromAdc = document.getElementById('plot-tdc-trailing-fromadc');
      if (tdcTrailingFromAdc) {
        tdcTrailingFromAdc.src = `figs/dataquality/tdc/${run}_trailing_fromadc_hist.png`;
      }

      const lightyieldChavg = document.getElementById('plot-lightyield-chavg');
      if (lightyieldChavg) {
        lightyieldChavg.src = `figs/dataquality/lightyield/${run}_chavg_lightyield_hist.png`;
      }

      const xgyg = document.getElementById('plot-xgyg');
      if (xgyg) {
        xgyg.src = `figs/dataquality/xgyg/${run}_xgyg.png`;
      }
    }

 // Update PNG plots for the previous run (reference)
    function updatePrevRunDependentPlots(prevRunVal) {
      if (!prevRunVal) return;
      const run = prevRunVal.trim();

      const unixtime = document.getElementById('prev-plot-unixtime');
      if (unixtime) {
        unixtime.src = `figs/dataquality/unixtime/${run}_evnum_vs_unixtime.png`;
      }

      const spillnum = document.getElementById('prev-plot-spillnum');
      if (spillnum) {
        spillnum.src = `figs/dataquality/spillnum/${run}_evnum_vs_spillnum.png`;
      }

      const tdcLeading = document.getElementById('prev-plot-tdc-leading');
      if (tdcLeading) {
        tdcLeading.src = `figs/dataquality/tdc/${run}_leading_hist.png`;
      }

      const tdcTrailing = document.getElementById('prev-plot-tdc-trailing');
      if (tdcTrailing) {
        tdcTrailing.src = `figs/dataquality/tdc/${run}_trailing_hist.png`;
      }

      const tdcLeadingFromAdc = document.getElementById('prev-plot-tdc-leading-fromadc');
      if (tdcLeadingFromAdc) {
        tdcLeadingFromAdc.src = `figs/dataquality/tdc/${run}_leading_fromadc_hist.png`;
      }

      const tdcTrailingFromAdc = document.getElementById('prev-plot-tdc-trailing-fromadc');
      if (tdcTrailingFromAdc) {
        tdcTrailingFromAdc.src = `figs/dataquality/tdc/${run}_trailing_fromadc_hist.png`;
      }

      const lightyieldChavg = document.getElementById('prev-plot-lightyield-chavg');
      if (lightyieldChavg) {
        lightyieldChavg.src = `figs/dataquality/lightyield/${run}_chavg_lightyield_hist.png`;
      }

      const xgyg = document.getElementById('prev-plot-xgyg');
      if (xgyg) {
        xgyg.src = `figs/dataquality/xgyg/${run}_xgyg.png`;
      }
    }

    // ---- Helpers for previous run detection ----
    function parseRunNumber(runVal) {
      const m = runVal && runVal.match(/run(\d+)/);
      if (!m) return null;
      return {
        num: parseInt(m[1], 10),
        width: m[1].length, // zero padding width, e.g. 5 for "00005"
      };
    }

    function formatRunString(num, width) {
      return "run" + String(num).padStart(width, "0");
    }

    async function checkFileExists(url) {
      try {
        const res = await fetch(url, { method: "GET", cache: "no-store" });
        return res.ok;
      } catch {
        return false;
      }
    }

    // Search for the immediately preceding run that has an existing chavg_lightyield_hist file
    async function findPreviousRunWithData(latestRunVal) {
      const info = parseRunNumber(latestRunVal);
      if (!info) return null;
      const { num: latestNum, width } = info;

      for (let n = latestNum - 1; n >= 1; n--) {
        const candidate = formatRunString(n, width);
        const testUrl = `figs/dataquality/lightyield/${candidate}_chavg_lightyield_hist.png`;
        const exists = await checkFileExists(testUrl);
        if (exists) {
          return candidate;
        }
      }
      return null; // No valid previous run was found
    }

    function showPreviousRunSection(prevRunVal) {
      const section = document.getElementById('prev-section');
      const label   = document.getElementById('prev-run-label');
      if (!section || !prevRunVal) return;
      section.style.display = 'block';
      if (label) label.textContent = prevRunVal;
      updatePrevRunDependentPlots(prevRunVal);
    }


    async function startOrStopAlarm(shouldStart) {
      const beep = document.getElementById('beep-sound');
      if (shouldStart) {
        if (!soundEnabled) {
          const bar = document.getElementById('enable-bar');
          const btn = document.getElementById('enable-sound');
          if (bar) bar.style.display = 'block';
          if (btn) {
            btn.style.boxShadow = '0 0 0 3px rgba(255,0,0,0.35)';
            btn.style.animation = 'pulse 1.5s infinite';
          }
          return;
        }
        try {
          beep.loop = true;
          await beep.play();
        } catch {
          setTimeout(() => startOrStopAlarm(true), 5000);
        }
      } else {
        beep.pause();
        beep.currentTime = 0;
        beep.loop = false;
      }
    }

    async function loadRunAndDate() {
      const runCell  = document.getElementById('run-cell');
      const dateCell = document.getElementById('date-cell');
      let runVal = null, dateVal = null;

      try {
        [runVal, dateVal] = await Promise.all([
          fetchValueFromJs(RUN_JS),
          fetchValueFromJs(DATE_JS),
        ]);
      } catch {}

      if (!runVal)  { try { runVal  = await injectScriptAndCapture(RUN_JS);  } catch {} }
      if (!dateVal) { try { dateVal = await injectScriptAndCapture(DATE_JS); } catch {} }

      if (runVal)  runCell.textContent  = runVal;
      if (dateVal) dateCell.textContent = dateVal;

      return { runVal, dateVal };
    }

    async function evaluateStatusAndAlarm() {
      try {
        const { runVal, dateVal } = await loadRunAndDate();

        // Update run-dependent plots whenever we know the current run
        if (runVal) {
          updateRunDependentPlots(runVal);

          // Search for the previous run only on the first execution
          if (!prevRunResolved) {
            prevRunResolved = true;
            findPreviousRunWithData(runVal).then((prevRun) => {
              if (prevRun) {
                prevRunValue = prevRun;
                showPreviousRunSection(prevRun);
              }
            });
          }
        }

        if (!dateVal) {
          setLamp(false); setStatusBanner(false); startOrStopAlarm(true); lastIsOk = false; return;
        }

        const latest = toDateJST(dateVal);
        if (!latest) {
          setLamp(false); setStatusBanner(false); startOrStopAlarm(true); lastIsOk = false; return;
        }

        const now = new Date();
        const diffMinutes = (now - latest) / 60000;
        const isOk = diffMinutes <= THRESHOLD_MINUTES;

        setLamp(isOk);
        setStatusBanner(isOk);
        startOrStopAlarm(!isOk);
        lastIsOk = isOk;
      } catch {
        setLamp(false); setStatusBanner(false); startOrStopAlarm(true); lastIsOk = false;
      }
    }

    // ---- Enable sound button (one-time) ----
    (function setupEnableSound() {
      const bar  = document.getElementById('enable-bar');
      const btn  = document.getElementById('enable-sound');
      const beep = document.getElementById('beep-sound');

      if (bar) bar.style.display = 'block';

      if (!btn) return;
      btn.addEventListener('click', async () => {
        try {
          // 1st click: unlock audio permission
          if (!soundEnabled) {
            beep.volume = 0.01;
            beep.loop = false;
            await beep.play();
            await new Promise(r => setTimeout(r, 150));
            beep.pause();
            beep.currentTime = 0;
            beep.volume = 1.0;

            soundEnabled = true;
            btn.textContent = "Test alarm sound (click to start/stop)";

            // If already red, start real alarm immediately
            evaluateStatusAndAlarm();
            return;
          }

          // 2nd click and later: toggle test alarm ON/OFF
          if (!testAlarmPlaying) {
            beep.loop = true;
            beep.currentTime = 0;
            await beep.play();
            testAlarmPlaying = true;
            btn.textContent = "Stop test alarm";
          } else {
            beep.pause();
            beep.currentTime = 0;
            beep.loop = false;
            testAlarmPlaying = false;
            btn.textContent = "Test alarm sound (click to start/stop)";
          }
        } catch (e) {
          alert("Autoplay blocked. Please click again or check site permissions for sound.");
        }
      });
    })();

    // ---- Watchdogs ----
    // 1) Periodic status re-check (no page reload)
    window.addEventListener('load', () => {
      evaluateStatusAndAlarm();
      setInterval(evaluateStatusAndAlarm, 30000); // every 30s
    });
    // 2) When tab becomes visible again
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) evaluateStatusAndAlarm();
    });
    // 3) Audio watchdog: if red & enabled & audio is somehow paused, try to resume
    setInterval(() => {
      const beep = document.getElementById('beep-sound');
      if (!lastIsOk && soundEnabled && beep && beep.paused) {
        // try to restart quietly
        startOrStopAlarm(true);
      }
    }, 10000);
  </script>
</body>
</html>
